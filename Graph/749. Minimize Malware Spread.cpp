#include<bits/stdc++.h>
using namespace std;

/*
    Idea here is to first create a DSU with all edges in graph. This will help us in grouping and getting size of groups.
    Now, we know if there are more than one malware(infected) node in a group, then there is no-way we can minimize spread.
    
    On the other hand, if there is only a single node from a group in initial list of malware node, then our answer will be the
    node whose group is largest in size. We can easily get size if we know parent of a node using DSU.

    Ex:  Group1: 0->1->2    Group2: 3->4 , initial : [1,2,3]
                 ^     |
                 |_____|   

        Here 1 and 2 are infected, thus there is no way we can minimize spread by removing either 1 or 2 as all node will get infected anyways.
        Now, if we remove 3, we will surely minimize spread in group 2. And its size is 2. Thus, spread is minimized when whole group is not infected.
        Since, M(1) = M(2) = 3 and M(3) = 0. Thus our answer is 3, as it has minimum infection. Or in other words maxmimum un-infected nodes.
*/

class DSU {
    vector<int> parent, size;
public: 
    
    DSU(int n) {
        for(int i=0; i<=n; i++) {
            parent.push_back(i);
            size.push_back(1);
        }
    }
    
    int findParent(int num) {
        if(parent[num] == num) return num;
        return parent[num] = findParent(parent[num]);
    }
    
    void unionBySize(int u, int v) {
        int parU = findParent(u);
        int parV = findParent(v);
        
        if(parU == parV) return;
        
        if(size[parU] <= size[parV]) {
            parent[parU] = parV;
            size[parV] += size[parU];
        }
        else {
            parent[parV] = parU;
            size[parU] += size[parV];
        }
    }
    
    int getSize(int n) {
        return size[n];
    }
};

class Solution {
public:
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {

        int n = graph.size();
        
        DSU dsu(n);
        
        for(int i=0; i<n; i++) {
            for(int j=i+1; j<n; j++) {
                if(graph[i][j]) dsu.unionBySize(i, j);
            }
        }
        
        vector<int> infected(n, 0);
        int minNode = n+1;
        for(auto& it : initial) {
            minNode = min(minNode, it);
            int par = dsu.findParent(it);
            infected[par]++;
        }
        
        int maxSize = 0, node = -1;
        for(auto& i : initial) {
            int par = dsu.findParent(i);
            if(infected[par] == 1) {
                int size = dsu.getSize(par);
                
                if(size >= maxSize) {
                    if(size == maxSize) node = min(node, i);
                    else node = i;
                    maxSize = size;
                }
            }
        }
        return node == -1 ? minNode : node;
    }
};

/*
Sample TC : 

[[1,1,0],[1,1,0],[0,0,1]]
[0,1,2]

[[1,1,1,0,0],[1,1,1,0,0],[1,1,1,0,0],[0,0,0,1,1],[0,0,0,1,1]]
[0,1,2,3]
*/